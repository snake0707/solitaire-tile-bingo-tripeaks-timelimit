<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solitaire Tile Bingo - Level Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 30px 15px;
        }
        .container {
            max-width: 600px;
            width: 100%;
        }
        h1 {
            text-align: center;
            margin-bottom: 24px;
            color: #ffd700;
        }
        .config {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .config label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 14px;
        }
        .config input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 16px;
            margin-bottom: 14px;
        }
        .row {
            display: flex;
            gap: 12px;
        }
        .row > div { flex: 1; }
        button#btn-generate {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.15s;
        }
        button#btn-generate:active { transform: scale(0.97); }
        button#btn-generate:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .progress-container {
            margin-top: 20px;
        }
        .progress-bar-outer {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #81c784);
            border-radius: 6px;
            width: 0%;
            transition: width 0.15s ease;
        }
        .progress-label {
            font-size: 13px;
            color: #aaa;
            text-align: center;
        }
        #log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 14px;
            margin-top: 16px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Level Generator</h1>
        <div class="config">
            <div class="row">
                <div>
                    <label for="start-level">Start Level</label>
                    <input type="number" id="start-level" value="1" min="1" max="10">
                </div>
                <div>
                    <label for="num-levels">Number of Levels</label>
                    <input type="number" id="num-levels" value="2" min="1" max="10">
                </div>
            </div>
            <label for="layouts-per-level">Layouts per Level</label>
            <input type="number" id="layouts-per-level" value="5" min="1" max="20">
            <button id="btn-generate">Generate Levels</button>
        </div>
        <div class="progress-container">
            <div class="progress-bar-outer">
                <div class="progress-bar-inner" id="progress-fill"></div>
            </div>
            <div class="progress-label" id="progress-label">Ready</div>
        </div>
        <div id="log"></div>
    </div>

<script src="categories.js"></script>
<script src="level_settings.js"></script>
<script src="color_settings.js"></script>
<script>
// ─── Data ────────────────────────────────────────────────────────────────

// ─── Generation Logic ──────────────────────────────────────────────

function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function generateCards(config) {
    const shuffledCats = shuffleArray([...ALL_CATEGORY_KEYS]);
    const activeCatKeys = shuffledCats.slice(0, config.numCategories);

    const categoryColorMap = {};
    activeCatKeys.forEach((key, i) => {
        categoryColorMap[key] = CARD_COLORS[i % CARD_COLORS.length];
    });

    // Separate gold (hand pile) and regular (grid) cards
    const goldCards = [];
    const regularCards = [];
    const regularCountPerCat = {};

    activeCatKeys.forEach(catKey => {
        const cat = CATEGORIES[catKey];
        goldCards.push({
            type: 'gold',
            category: catKey,
            name: cat.name,
            isText: cat.isText,
        });

        const shuffledItems = shuffleArray([...cat.items]);
        const count = Math.min(config.cardsPerCategory, shuffledItems.length);
        regularCountPerCat[catKey] = count;
        for (let i = 0; i < count; i++) {
            regularCards.push({
                type: 'regular',
                category: catKey,
                name: shuffledItems[i].name,
                image: shuffledItems[i].image,
                isText: cat.isText,
            });
        }
    });

    const categoryTargets = { ...regularCountPerCat };

    // Pad regular cards to fill grid positions (minus filler slots)
    const regularPositions = config.totalPositions - (config.numFillers || 0);
    while (regularCards.length < regularPositions) {
        const catKey = activeCatKeys[Math.floor(Math.random() * activeCatKeys.length)];
        const cat = CATEGORIES[catKey];
        const item = cat.items[Math.floor(Math.random() * cat.items.length)];
        regularCards.push({
            type: 'regular',
            category: catKey,
            name: item.name,
            image: item.image,
            isText: cat.isText,
        });
        regularCountPerCat[catKey]++;
        categoryTargets[catKey] = regularCountPerCat[catKey];
    }

    // Generate filler cards from non-active categories
    const fillerCards = [];
    const inactiveCatKeys = ALL_CATEGORY_KEYS.filter(k => !activeCatKeys.includes(k));
    const numFillers = config.numFillers || 0;
    for (let i = 0; i < numFillers && inactiveCatKeys.length > 0; i++) {
        const catKey = inactiveCatKeys[Math.floor(Math.random() * inactiveCatKeys.length)];
        const cat = CATEGORIES[catKey];
        const item = cat.items[Math.floor(Math.random() * cat.items.length)];
        fillerCards.push({
            type: 'filler',
            category: catKey,
            name: item.name,
            image: item.image,
            isText: cat.isText,
        });
    }

    // Determine which layer-0 positions get fillers
    const layer0Positions = [];
    const layerMask0 = config.layout[0];
    for (let r = 0; r < layerMask0.length; r++) {
        for (let c = 0; c < layerMask0[r].length; c++) {
            if (layerMask0[r][c]) layer0Positions.push({ r, c });
        }
    }
    shuffleArray(layer0Positions);
    const fillerPositionSet = new Set();
    for (let i = 0; i < Math.min(numFillers, layer0Positions.length); i++) {
        fillerPositionSet.add(`${layer0Positions[i].r}-${layer0Positions[i].c}`);
    }

    shuffleArray(regularCards);
    shuffleArray(goldCards);

    // Build grid cards (fillers at layer 0 only)
    const cards = [];
    const cardMap = {};
    let regularIdx = 0;
    let fillerIdx = 0;

    for (let L = 0; L < config.numLayers; L++) {
        const layerMask = config.layout[L];
        for (let r = 0; r < layerMask.length; r++) {
            for (let c = 0; c < layerMask[r].length; c++) {
                if (!layerMask[r][c]) continue;
                let card;
                if (L === 0 && fillerPositionSet.has(`${r}-${c}`) && fillerIdx < fillerCards.length) {
                    card = fillerCards[fillerIdx++];
                } else {
                    if (regularIdx >= regularCards.length) continue;
                    card = regularCards[regularIdx++];
                }
                const key = `${L}-${r}-${c}`;
                const cardObj = {
                    id: cards.length,
                    layer: L,
                    row: r,
                    col: c,
                    card: card,
                    faceUp: false,
                    removed: false,
                };
                cards.push(cardObj);
                cardMap[key] = cardObj;
            }
        }
    }

    // Build 1-to-1 covering relationships
    const coveredBy = {};
    for (const card of cards) {
        const key = `${card.layer}-${card.row}-${card.col}`;
        coveredBy[key] = [];
    }
    for (const card of cards) {
        if (card.layer === 0) continue;
        const L = card.layer;
        const R = card.row;
        const C = card.col;
        const upperKey = `${L}-${R}-${C}`;
        const lowerKey = `${L - 1}-${R}-${C}`;
        if (cardMap[lowerKey]) {
            coveredBy[lowerKey].push(upperKey);
        }
    }

    // Update face-up states
    for (const card of cards) {
        if (card.removed) continue;
        const key = `${card.layer}-${card.row}-${card.col}`;
        const coveringKeys = coveredBy[key] || [];
        card.faceUp = coveringKeys.every(ck => {
            const cc = cardMap[ck];
            return !cc || cc.removed;
        });
    }

    // handPile = gold cards (shuffled), handDisplay starts empty
    const handPile = goldCards;

    return { cards, cardMap, coveredBy, categoryTargets, categoryColorMap, handPile };
}

// ─── DFS Solver (new mechanics) ──────────────────────────────────────

function verifySolvable(cards, cardMap, coveredBy, categoryTargets, bingosNeeded, maxMoves, maxSlots, handPile) {
    const result = { solvable: false, nodesExplored: 0 };
    const state = {
        removed: new Set(),
        slots: new Array(maxSlots).fill(null),
        cleared: Array.from({ length: 5 }, () => Array(5).fill(false)),
        movesLeft: maxMoves,
        completedCount: 0,
        handPile: [...handPile],       // copy
        handDisplay: [],
        recycleCount: 0,
    };

    let nodesExplored = 0;
    const MAX_NODES = 800000;
    const MAX_RECYCLES = 3;

    function simIsFaceUp(cardObj) {
        if (state.removed.has(cardObj.id)) return false;
        const key = `${cardObj.layer}-${cardObj.row}-${cardObj.col}`;
        const coveringKeys = coveredBy[key] || [];
        return coveringKeys.every(ck => {
            const cc = cardMap[ck];
            return !cc || state.removed.has(cc.id);
        });
    }

    function countBingoLines() {
        let count = 0;
        for (let r = 0; r < 5; r++) {
            if (state.cleared[r].every(v => v)) count++;
        }
        for (let c = 0; c < 5; c++) {
            if ([0, 1, 2, 3, 4].every(r => state.cleared[r][c])) count++;
        }
        if ([0, 1, 2, 3, 4].every(i => state.cleared[i][i])) count++;
        if ([0, 1, 2, 3, 4].every(i => state.cleared[i][4 - i])) count++;
        return count;
    }

    function getMoves() {
        const moves = [];
        const hasEmptySlot = state.slots.some(s => s === null);

        // Move type: collect_regular — face-up basic card matching active slot
        for (const cardObj of cards) {
            if (state.removed.has(cardObj.id)) continue;
            if (!simIsFaceUp(cardObj)) continue;
            if (cardObj.card.type === 'regular') {
                const slotIdx = state.slots.findIndex(
                    s => s !== null && s.key === cardObj.card.category && s.collected < s.target
                );
                if (slotIdx !== -1) {
                    moves.push({ type: 'collect_regular', cardObj, slotIndex: slotIdx });
                }
            }
        }

        // Move type: place_from_display — top display card into empty slot
        if (state.handDisplay.length > 0 && hasEmptySlot) {
            moves.push({ type: 'place_from_display' });
        }

        // Move type: flip_hand — flip top pile card to display
        if (state.handPile.length > 0) {
            moves.push({ type: 'flip_hand' });
        }

        // Move type: recycle — reverse display back into pile (limited)
        if (state.handPile.length === 0 && state.handDisplay.length > 0 && state.recycleCount < MAX_RECYCLES) {
            moves.push({ type: 'recycle' });
        }

        // Priority: collect_regular first, then place, flip, recycle last
        const priority = { collect_regular: 0, place_from_display: 1, flip_hand: 2, recycle: 3 };
        moves.sort((a, b) => {
            const pa = priority[a.type];
            const pb = priority[b.type];
            if (pa !== pb) return pa - pb;
            // Among regular collects, prefer ones closer to completion
            if (a.type === 'collect_regular' && b.type === 'collect_regular') {
                const aRemain = state.slots[a.slotIndex].target - state.slots[a.slotIndex].collected;
                const bRemain = state.slots[b.slotIndex].target - state.slots[b.slotIndex].collected;
                return aRemain - bRemain;
            }
            return 0;
        });

        return moves;
    }

    function applyMove(move) {
        const undo = { type: move.type };
        state.movesLeft--;

        if (move.type === 'collect_regular') {
            undo.cardId = move.cardObj.id;
            undo.layer = move.cardObj.layer;
            undo.row = move.cardObj.row;
            undo.col = move.cardObj.col;
            state.removed.add(move.cardObj.id);

            if (move.cardObj.layer === 0) {
                state.cleared[move.cardObj.row][move.cardObj.col] = true;
                undo.clearedCell = true;
            }

            const slot = state.slots[move.slotIndex];
            undo.slotIndex = move.slotIndex;
            undo.prevCollected = slot.collected;
            slot.collected++;
            if (slot.collected >= slot.target) {
                undo.completedSlot = { key: slot.key, collected: undo.prevCollected, target: slot.target };
                state.slots[move.slotIndex] = null;
                state.completedCount++;
                undo.completedCategory = true;
            }
        } else if (move.type === 'place_from_display') {
            const card = state.handDisplay.pop();
            undo.card = card;
            const emptyIdx = state.slots.findIndex(s => s === null);
            state.slots[emptyIdx] = {
                key: card.category,
                collected: 0,
                target: categoryTargets[card.category] || 0,
            };
            undo.slotIndex = emptyIdx;
        } else if (move.type === 'flip_hand') {
            const card = state.handPile.pop();
            state.handDisplay.push(card);
            undo.card = card;
        } else if (move.type === 'recycle') {
            undo.displaySnapshot = [...state.handDisplay];
            state.handPile = [...state.handDisplay].reverse();
            state.handDisplay = [];
            state.recycleCount++;
        }

        return undo;
    }

    function undoMove(undo) {
        state.movesLeft++;

        if (undo.type === 'collect_regular') {
            state.removed.delete(undo.cardId);
            if (undo.clearedCell) {
                state.cleared[undo.row][undo.col] = false;
            }
            if (undo.completedCategory) {
                state.completedCount--;
                state.slots[undo.slotIndex] = undo.completedSlot;
            } else {
                state.slots[undo.slotIndex].collected--;
            }
        } else if (undo.type === 'place_from_display') {
            state.slots[undo.slotIndex] = null;
            state.handDisplay.push(undo.card);
        } else if (undo.type === 'flip_hand') {
            state.handDisplay.pop();
            state.handPile.push(undo.card);
        } else if (undo.type === 'recycle') {
            state.handDisplay = undo.displaySnapshot;
            state.handPile = [];
            state.recycleCount--;
        }
    }

    function solve() {
        nodesExplored++;
        if (nodesExplored > MAX_NODES) return false;

        if (countBingoLines() >= bingosNeeded) return true;
        if (state.movesLeft <= 0) return false;

        const moves = getMoves();
        if (moves.length === 0) return false;

        for (const move of moves) {
            const undo = applyMove(move);
            if (solve()) return true;
            undoMove(undo);
        }

        return false;
    }

    result.solvable = solve();
    result.nodesExplored = nodesExplored;
    return result;
}

// ─── Generator Logic ───────────────────────────────────────────────

function generateSolvableLayout(level) {
    const config = getLevelSettings(level);
    const maxAttempts = 200;
    let totalNodes = 0;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const gen = generateCards(config);
        const result = verifySolvable(
            gen.cards, gen.cardMap, gen.coveredBy,
            gen.categoryTargets, config.bingosNeeded,
            config.totalPositions + gen.handPile.length * 2, // generous move budget
            config.maxSlots, gen.handPile
        );
        totalNodes += result.nodesExplored;
        if (result.solvable) {
            return {
                layout: {
                    config: {
                        bingosNeeded: config.bingosNeeded,
                        maxSlots: config.maxSlots,
                        timeLimit: config.timeLimit,
                        penaltyTime: config.penaltyTime,
                    },
                    cards: gen.cards.map(c => ({
                        layer: c.layer, row: c.row, col: c.col,
                        card: { ...c.card },
                    })),
                    categoryTargets: { ...gen.categoryTargets },
                    handPile: gen.handPile.map(c => ({ ...c })),
                    handDisplay: [],
                },
                attempts: attempt + 1,
                totalNodes,
            };
        }
    }
    return { layout: null, attempts: maxAttempts, totalNodes };
}

function downloadJSON(filename, data) {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// ─── UI ────────────────────────────────────────────────────────────

const btnGenerate = document.getElementById('btn-generate');
const progressFill = document.getElementById('progress-fill');
const progressLabel = document.getElementById('progress-label');
const logEl = document.getElementById('log');

function log(msg) {
    logEl.textContent += msg + '\n';
    logEl.scrollTop = logEl.scrollHeight;
}

function setProgress(pct, label) {
    progressFill.style.width = pct + '%';
    progressLabel.textContent = label;
}

btnGenerate.addEventListener('click', async () => {
    const startLevel = parseInt(document.getElementById('start-level').value, 10) || 1;
    const numLevels = parseInt(document.getElementById('num-levels').value, 10) || 2;
    const layoutsPerLevel = parseInt(document.getElementById('layouts-per-level').value, 10) || 5;

    btnGenerate.disabled = true;
    logEl.textContent = '';
    log(`Starting generation: levels ${startLevel}-${startLevel + numLevels - 1}, ${layoutsPerLevel} layouts each`);

    const totalWork = numLevels * layoutsPerLevel;
    let completed = 0;

    for (let lv = startLevel; lv < startLevel + numLevels; lv++) {
        const layouts = [];
        const cfg = getLevelSettings(lv);
        log(`\n--- Level ${lv} (${cfg.numLayers}L, ${cfg.totalPositions} grid cards, ${cfg.maxSlots} slots, ${cfg.bingosNeeded} bingos, ${cfg.numCategories} cats, ${cfg.timeLimit}s) ---`);

        for (let i = 0; i < layoutsPerLevel; i++) {
            setProgress((completed / totalWork) * 100, `Level ${lv}: layout ${i + 1}/${layoutsPerLevel}`);

            // Yield to keep UI responsive
            await new Promise(r => setTimeout(r, 0));

            const result = generateSolvableLayout(lv);
            if (result.layout) {
                layouts.push(result.layout);
                log(`  Layout ${i + 1}: OK (${result.layout.cards.length} grid + ${result.layout.handPile.length} hand, ${result.attempts} attempts, ${result.totalNodes.toLocaleString()} nodes)`);
            } else {
                log(`  Layout ${i + 1}: FAILED after ${result.attempts} attempts (${result.totalNodes.toLocaleString()} nodes explored)`);
            }
            completed++;
        }

        if (layouts.length > 0) {
            downloadJSON(`level_${lv}.json`, layouts);
            log(`  Downloaded level_${lv}.json (${layouts.length} layouts)`);
        } else {
            log(`  WARNING: No solvable layouts found for level ${lv}`);
        }
    }

    setProgress(100, 'Done!');
    log('\nGeneration complete!');
    btnGenerate.disabled = false;
});
</script>
</body>
</html>
